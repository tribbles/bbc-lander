crtcreg  = &fe00
crtcval  = &fe01
ula      = &fe20
heading_addr = &0011
altitude_addr = &0110
direction_addr = &0032
score_addr = &00c9
fuel_addr = &01d0

.set_mode
{
; Set MODE 4
    LDA #22
    JSR oswrch
    LDA #4
    JSR oswrch
    
    LDY #15
.crtc_loop
    LDA modevars, Y
    STY crtcreg
    STA crtcval
    DEY
    BPL crtc_loop
.end_crtc

    LDA #&88
    STA ula
    LDA #&07
.ula_loop
    STA ula + 1
    EOR #&87
    STA ula + 1
    EOR #&87
    CLC
    ADC #&10
    BPL ula_loop
    
    LDA #HI(screen)
    STA current_screen_hi
    
    LDX #&4
    JMP set_colour
}

.plot_line
{
    LDA x1
    EOR x0
    BEQ plot_vline
    LDA y1
    EOR y0
    BEQ plot_hline
    
.pl_restart    
    LDA x1
    SEC
    SBC x0
    BMI pl_dxneg
    STA dx       ; dx = x1 - x0
    LDX #0
    LDA y1
    SEC
    SBC y0
    BPL pl_dypos
    INX
    EOR #&ff
    CLC
    ADC #1
.pl_dypos
    STA dy       ; dy = y1 - y0 (although if negative, it'll select a different quadrant)
    
    CMP dx
    BCC pl_dxgtdy
    INX
    INX
.pl_dxgtdy
    LDA quadrant_h, X
    PHA
    LDA quadrant_l, X
    PHA
    RTS
    
.quadrant_h
    EQUB HI(plq1 - 1), HI(plq2 - 1), HI(plq3 - 1), HI(plq4 - 1)
.quadrant_l
    EQUB LO(plq1 - 1), LO(plq2 - 1), LO(plq3 - 1), LO(plq4 - 1)

.plot_vline
    LDA x0
    LDX y0
    LDY y1
    JMP vline
    
.plot_hline
    LDA y0
    LDX x0
    LDY x1
    JMP hline
    
.pl_dxneg
    LDA x1
    LDX x0
    STA x0
    STX x1
    LDA y1
    LDX y0
    STX y1
    STA y0
    JMP pl_restart
}

.plq1
{
; dy is +ve; dy is < dx
    LDA dx
    LSR A
    EOR #&ff
    CLC
    ADC #1
    STA plerror  ; error = -(dx / 2)
    LDA x0
    STA plx      ; x = x0
    STA pllast
    LDA y0
    STA ply      ; y = y0
.plq1_loop
    LDX plx
    CPX x1
    BEQ plq1_done
    LDA plerror
    CLC
    ADC dy       ; error = error + dy
    BPL plq1_inc
    STA plerror
    INC plx
    JMP plq1_loop

.plq1_inc
    SEC
    SBC dx       ; error = error - dx
    STA plerror
    
    LDA ply
    LDX pllast
    LDY plx
    JSR hline
    INC plx
    LDA plx
    STA pllast
    INC ply
    JMP plq1_loop
    
.plq1_done
    LDA ply
    LDX pllast
    LDY x1
    JMP hline
}
    
.plq2
{
; dy is -ve; dy is < dx
    LDA dx
    LSR A
    EOR #&ff
    CLC
    ADC #1
    STA plerror  ; error = -(dx / 2)
    LDA x0
    STA plx      ; x = x0
    STA pllast
    LDA y0
    STA ply      ; y = y0
.plq2_loop
    LDX plx
    CPX x1
    BEQ plq2_done
    LDA plerror
    CLC
    ADC dy       ; error = error + dy
    BPL plq2_inc
    STA plerror
    INC plx
    JMP plq2_loop

.plq2_inc
    SEC
    SBC dx       ; error = error - dx
    STA plerror
    
    LDA ply
    LDX pllast
    LDY plx
    JSR hline
    INC plx
    LDA plx
    STA pllast
    DEC ply
    JMP plq2_loop
    
.plq2_done
    LDA ply
    LDX pllast
    LDY x1
    JMP hline
}

.plq3
{
; dy is +ve; dy > dx
    LDA dy
    LSR A
    EOR #&ff
    CLC
    ADC #1
    STA plerror  ; error = -(dy / 2)
    LDA y0
    STA ply
    STA pllast
    LDA x0
    STA plx
.plq3_loop
    LDX ply
    CPX y1
    BEQ plq3_done
    LDA plerror
    CLC
    ADC dx       ; error = error + dx
    BPL plq3_inc
    STA plerror
    INC ply
    JMP plq3_loop
    
.plq3_inc
    SEC
    SBC dy       ; error = error - dy
    STA plerror
    LDA plx
    LDX pllast
    LDY ply
    JSR vline
    INC ply
    LDA ply
    STA pllast
    INC plx
    JMP plq3_loop
    
.plq3_done
    LDA plx
    LDX pllast
    LDY y1
    JMP vline
}

.plq4
{
; dy is -ve; dy > dx
    LDA dy
    LSR A
    EOR #&ff
    CLC
    ADC #1
    STA plerror  ; error = -(dy / 2)
    LDA y1
    STA ply
    STA pllast
    LDA x1
    STA plx
.plq4_loop
    LDX ply
    CPX y0
    BEQ plq4_done
    LDA plerror
    CLC
    ADC dx       ; error = error + dx
    BPL plq4_inc
    STA plerror
    INC ply
    JMP plq4_loop
    
.plq4_inc
    SEC
    SBC dy       ; error = error - dy
    STA plerror
    LDA plx
    LDX pllast
    LDY ply
    JSR vline
    INC ply
    LDA ply
    STA pllast
    DEC plx
    JMP plq4_loop
    
.plq4_done
    LDA plx
    LDX pllast
    LDY y0
    JMP vline
}

    ALIGN 8
.bits
    EQUB 128, 64, 32, 16, 8, 4, 2, 1
.leftbits
    EQUB &80, &c0, &e0, &f0, &f8, &fc, &fe, &ff
.rightbits
    EQUB &ff, &7f, &3f, &1f, &0f, &07, &03, &01
.shl6
    EQUB 0, 64, 128, 192

.set_colour
{
; X is colour
    LDA c1, X
    STA pixelmask
    LDA c2, X
    STA pixelmask + 1
    RTS

.c1
    EQUB &00, &55, &55, &ff, &ff
.c2
    EQUB &00, &00, &aa, &aa, &ff
}

.modevars
    EQUB 63       ; R0 (Horizontal total)
    EQUB 32       ; R1 (Horizontal displayed)
    EQUB 49 - 4   ; R2 (Horizontal sync position)
    EQUB &24      ; R3 (Sync width)
    EQUB 38       ; R4 (Vertical total)
    EQUB 0        ; R5 (Vertical total adjust)
    EQUB 24       ; R6 (Vertical displayed)
    EQUB 34 - 3   ; R7 (Vertical sync)
    EQUB &c1      ; R8 (Interlace and display)
    EQUB 7        ; R9 (Scan lines per character)
    EQUB 0        ; R10 (Cursor start)
    EQUB 8        ; R11 (Cursor end)
    EQUB &0d      ; R12 (Display start, high)
    EQUB &00      ; R13 (Display end, low)
    EQUB &00      ; R14 (Cursor address, high)
    EQUB &00      ; R15 (Cursor address, low)

.init_screen
{
    LDY #0
.is_loop
    LDA screen_data, Y
    STA screen1, Y
    STA screen2, Y
    LDA screen_data + 256, Y
    STA screen1 + 256, Y
    STA screen2 + 256, Y
    LDA screen_data + 512, Y
    STA screen1 + 23 * 256, Y
    STA screen2 + 23 * 256, Y
    DEY
    BNE is_loop
    RTS
.screen_data
    INCBIN "title.bin"
    INCBIN "baseline.bin"
}

.clear_bank
{
    LDA #0
    TAY
    LDX current_screen_hi
    CPX #HI(screen1)
    BEQ clr1
.clr2
FOR n, 2, 22
    STA screen2 + n * 256, Y
NEXT
    DEY
    BNE clr2
    RTS
.clr1
FOR n, 2, 22
    STA screen1 + n * 256, Y
NEXT
    DEY
    BNE clr1
    RTS
}

.swap_banks
{
osbyte   = &fff4

    LDA current_screen_hi
    EOR #HI(screen1) EOR HI(screen2)
    STA current_screen_hi
    TAY
    LSR A
    LSR A
    LSR A
    EOR #(HI(screen1) EOR HI(screen2)) >> 3
    LDX #12
    STX crtcreg
    STA crtcval
    ;CMP #HI(screen1)
    LDA #19
    JMP osbyte
}

.prepare_char
    STX write_font1 + 1
    STX write_font2 + 1
    TYA
    CLC
    ADC #HI(screen1)
    STA write_font1 + 2
    TYA
    CLC
    ADC #HI(screen2)
    STA write_font2 + 2
    RTS

.plot_char
; X is LO offset
; Y is HI offset
; A is the character
; A, X and Y are corrupted
    STX write_font1 + 1
    STX write_font2 + 1
    TAX
    TYA
    CLC
    ADC #HI(screen1)
    STA write_font1 + 2
    TYA
    CLC
    ADC #HI(screen2)
    STA write_font2 + 2
    TXA
.plot_nextchar
; A is the character
; A and Y are corrupted (X is preserved)
    STA mathc
    ASL A
    ADC mathc
    ASL A
    ADC #LO(font)
    STA read_font + 1
    LDA #0
    ADC #HI(font)
    STA read_font + 2
    LDY #5
.read_font
    LDA &ffff, Y
.write_font1
    STA &ffff, Y
.write_font2
    STA &ffff, Y
    DEY
    BPL read_font
    LDA write_font1 + 1
    CLC
    ADC #8
    STA write_font1 + 1
    STA write_font2 + 1
    RTS

.plot_3digits
{
    JSR prepare_char
    JSR bin2dec16
    CMP #3
    BCS p3d_write
    TAX
.p3d_zeroloop
    LDA #0
    JSR plot_nextchar
    INX
    CPX #3
    BNE p3d_zeroloop
.p3d_write
    LDX #0
.p3d_loop
    LDA digits, X
    BMI p3d_done
    JSR plot_nextchar
    INX
    BNE p3d_loop
.p3d_done
    RTS
}

.font
    INCBIN  "font.bin"

.press_return
    EQUS "Press RETURN to play", 0

.text_keys
    EQUS "Z", 10, "X", 10, "K", 10, "L", 10, "SPACE", 0

.text_meaning
    EQUS "Anti", 0
.text_right
    EQUS "clockwise", 10
    EQUS "Clockwise", 10
    EQUS "  Nose up", 10
    EQUS "Nose down", 10
    EQUS "   Thrust", 0
.text_dead
    EQUS "Oh dear, it looks like", 10
    EQUS "you hit the floor. This", 10
    EQUS "can be a career limiting", 10
    EQUS "incident some times, but", 10
    EQUS "in this case, you are", 10
    EQUS "most definitely dead.", 10, 10, 10
    EQUS "Please feel free to have", 10
    EQUS "another go. If you dare!", 10, 10, 10
    EQUS "Press RETURN to continue", 0

.draw_text
{
    STX rd_addr + 1
    STY rd_addr + 2
.retline
    LDA x0
    STA wr_addr + 1
    LDA y0
    CLC
    ADC current_screen_hi
    STA wr_addr + 2
.rd_addr
    LDA rd_addr
    BEQ draw_done
    CMP #10
    BEQ newline
    SEC
    SBC #32
    BMI draw_done
    BEQ skip_char
    LDX #&c0 >> 3
    STX y1
    ASL A
    ROL y1
    ASL A
    ROL y1
    ASL A
    ROL y1
    STA chr_addr + 1
    LDA y1
    STA chr_addr + 2
    LDX #7
.chr_addr
    LDA rd_addr, X
    STA x1
    LSR A
    AND x1
.wr_addr
    STA rd_addr, X
    DEX
    BPL chr_addr
.skip_char
    LDA wr_addr + 1
    CLC
    ADC #8
    STA wr_addr + 1
    BCC inc_rd
    INC wr_addr + 2
.inc_rd
    INC rd_addr + 1
    BNE rd_addr
    INC rd_addr + 2
    BPL rd_addr
.draw_done
    RTS
.newline
    INC y0
    INC rd_addr + 1
    BNE retline
    INC rd_addr + 2
    BPL retline
    RTS
}