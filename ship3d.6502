ship_pointcount = 6
ship_factcount = 8

MACRO ROUNDUP
    TAY
    LDX mathc + 1
    BMI .noround
    INY
.noround
ENDMACRO

MACRO ADDTBN nn, tt
    STA tt
    TAY
    BMI neg
    LDX nn
    BPL 
ENDMACRO

.rotate_ship
{
    siny = x0
    cosy = y0
    sinz = x1
    cosz = y1

; Get the sine and cosine of the angles
    LDA yangle
    JSR hrcos
    STA cosy
    LDA yangle
    JSR hrsin
    STA siny
    LDA zangle
    JSR hrcos
    STA cosz
    LDA zangle
    JSR hrsin
    STA sinz
.ptsloop
    LDA ship_xpoints
    LDX cosx
    JSR mul_tbn
    ROUNDUP
    STY jtmp

    LDA ship_zpoints
    LDX sinx
    JSR mul_tbn
    ROUNDUP

}

.ship_xpoints
; X, Y, Z, but uses top bit to indicate negative (TBN), rather than 2's complement
    EQUB 0, 0, 18, 7, 7 OR 128, 18 OR 128
.ship_ypoints
    EQUB 7, 0, 3, 0, 0, 3
.ship_zpoints
    EQUB 0, 15 OR 128, 0, 18, 18, 0

.ship_xrot
    SKIP ship_pointcount
.ship_yrot
    SKIP ship_pointcount
.ship_zrot
    SKIP ship_pointcount

.ship_x2d
    SKIP ship_pointcount * 2
.ship_y2d
    SKIP ship_pointcount * 2

.ship_facets
; Ship facets consist of a bitfield
; Bits 0..1 = Vector point 1 (allows 0-3)
; Bits 2..4 = Vector point 2 (allows 0-7)
; Bits 5..7 = Vector point 3 (allows 0-7)

; Top
    EQUB (0 << 0) OR (1 << 2) OR (2 << 5)
    EQUB (0 << 0) OR (2 << 2) OR (3 << 5)
    EQUB (0 << 0) OR (3 << 2) OR (4 << 5)
    EQUB (0 << 0) OR (4 << 2) OR (5 << 5)
    EQUB (0 << 0) OR (5 << 2) OR (1 << 5)
; Bottom
    EQUB (1 << 0) OR (3 << 2) OR (2 << 5)
    EQUB (1 << 0) OR (4 << 2) OR (3 << 5)
    EQUB (1 << 0) OR (5 << 2) OR (4 << 5)

.hrcos
; Get the cosine of A (0 .. 255)
; Returns the cosine, but using top-bit set for negative (TBN), rather than 2's complement
    CLC
    ADC #64
.hrsin
; Get the sine of A (0 .. 255)
; Returns the sine, but using top-bit set for negative (TBN), rather than 2's complement
{
    TAX
    BMI negate
    AND #64
    BEQ quarter1
    TXA
    AND #63
    EOR #63
    TAX
.quarter1
    LDA hrsintab, X
    RTS
.negate
    AND #127
    TAX
    AND #64
    BEQ quarter3
    TXA
    AND #63
    TAX
.quarter3
    LDA hrsintab, X
    ORA #128
    RTS

.hrsintab
FOR n, 0, 63
    EQUB SIN(RAD(n * 90 / 64)) * 63
NEXT
}

.mul_tbn
; TBN multiply 8-bit by 8-bit
; Values in A and X
; Returns A as the top-byte, and mathc + 1 as the low-byte - multiplied by 4
; Corrupts Y
{
    TAY
    AND #127
    BEQ iszero
    STA mathc + 0
    STY mathc + 2

    TXA
    AND #127
    BEQ iszero
    TAY
    DEY
    STY mathc + 1

    TXA
    EOR mathc + 2
    STA mathc + 2           ; This is now the sign value for the result

    LDA #0
    LDX #6                  ; Only 6 bits really need to be dealt with (top bit is clear on both values)
    LSR mathc + 0
.mulloop
    BCC noadd
    ;CLC
    ADC mathc + 1
.noadd
    ROR A
    ROR mathc + 0
    DEX
    BNE mulloop
    LDX mathc + 2
    BPL noinv
    EOR #128                ; Mark it as negative
.noinv
    RTS
    
.iszero
    STA mathc + 1
    RTS
}