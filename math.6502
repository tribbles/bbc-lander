.depth
    ; Calculates the coordinate based on the given depth
    ; Y = X or Y; X = depth
    ; Populates mathc with the given calculation
    LDA  divtableL, X
    STA  matha
    LDA  divtableH, X
    STA  matha + 1

.multbyy
    ; matha is the multiplier
    ; Y is the other multiplier
{
    TYA
    PHP
    BPL  mulpos
    EOR  #255
    SEC
    ADC  #0
.mulpos
    STA  mathb
    LDY  #0
    STY  mathc + 1
.mulloop
    LSR  mathb
    BCC  mulskip
    CLC
    TYA
    ADC  matha
    TAY
    LDA  mathc + 1
    ADC  matha + 1
    STA  mathc + 1
.mulskip
    ASL  matha
    ROL  matha + 1
    LDA  mathb
    BNE  mulloop

    STY  mathc
    PLP
    BPL  mulpos2
    LDA  #0
    SEC
    SBC  mathc
    STA  mathc
    LDA  #0
    SBC  mathc + 1
    STA  mathc + 1
.mulpos2
    RTS
}

    ; Calculates the cosine of A (0..255), multiplied by Y
.cos
{
    SEC
    SBC #64
}
    ; Calculates the sine of A (0..255), multiplied by Y
.sin
{
    CMP #0
    BPL sinquad12   ; If positive, we don't need to negate Y
    TAX             ; Here, we're relying on SIN(A + 180) = -SIN(A)
    TYA
    EOR #255
    CLC
    ADC #1
    TAY             ; Negate Y
    TXA
    AND #127        ; And convert A to 0..180
.sinquad12
    CMP #64
    BMI sinquad0
    AND #63         ; Here, we're relying on SIN(A) = SIN(180 - A) where A = 90..179
    EOR #63
.sinquad0
    TAX
    LDA sintable, X
    STA matha
    LDA #0
    STA matha + 1
    JMP multbyy
}

ALIGN    128
divmax = 40000
divadd = 33
.divtableL
    FOR n, 1, 64
    EQUB LO(divmax / (n + divadd))
    NEXT
.divtableH
    FOR n, 1, 64
    EQUB HI(divmax / (n + divadd))
    NEXT
.sintable
    FOR  n, 0, 63
    EQUB SIN(RAD(n * 90 / 64)) * 64
    NEXT