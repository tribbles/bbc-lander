
.depthY
    ; Calculates the coordinate based on the given depth
    ; Y = X or Y; X = depth
    ; Populates mathc with the given calculation
    LDA divtableLY, X
    STA matha
    LDA divtableHY, X
    STA matha + 1
    JMP multbyy

.depthX
    ; Calculates the coordinate based on the given depth
    ; Y = X or Y; X = depth
    ; Populates mathc with the given calculation
    LDA divtableLX, X
    STA matha
    LDA divtableHX, X
    STA matha + 1

.multbyy
    ; matha is the multiplier
    ; Y is the other multiplier
{
    STY mathb
    TYA
    BEQ iszero
    EOR matha + 1
    STA maths
    TYA
    BPL mulpos1
    EOR #255
    SEC
    ADC #0
    STA mathb
.mulpos1
    LDA matha + 1
    BPL mulpos2
    SEC
    LDA #0
    SBC matha
    STA matha
    LDA #0
    SBC matha + 1
    STA matha + 1
.mulpos2

    LDA #0
    STA mathc + 1
    LDX #8
.mull1
    LSR mathb
    BCC mull2
    TAY
    CLC
    LDA matha
    ADC mathc + 1
    STA mathc + 1
    TYA
    ADC matha + 1
.mull2
    ROR A
    ROR mathc + 1
    ROR mathc
    DEX
    BNE mull1
    STA mathc + 2
    
    LDA maths
    BPL mull3
    LDA mathc + 0
    EOR #255
    SEC
    ADC #0
    STA mathc + 0
    LDA mathc + 1
    EOR #255
    ADC #0
    STA mathc + 1
    LDA mathc + 2
    EOR #255
    ADC #0
    STA mathc + 2
.mull3
    RTS
.iszero
    STY mathc
    STY mathc + 1
    STY mathc + 2
    RTS
}

.mulxy
; Multiply X by Y
{
    TXA
    BEQ iszero
    STY mathc + 1
    EOR mathc + 1
    STA matha

; Check if X is positive
    TXA
    BEQ iszero
    BPL xpos
    EOR #255
    CLC
    ADC #1
    TAX
.xpos
    STX mathc

; Check if Y is nnegative
    TYA
    BPL ypos
    EOR #255
    CLC
    ADC #1
    STA mathc + 1
.ypos
    LDA #0
    LDX #8
    LSR mathc
.mulxyloop
    BCC no_add
    CLC
    ADC mathc + 1
.no_add
    ROR A
    ROR mathc
    DEX
    BNE mulxyloop
    STA mathc + 1
    LDA matha
    BMI bothneg
    RTS
.bothneg
    LDA #0
    SEC
    SBC mathc
    STA mathc
    LDA #0
    SBC mathc + 1
    STA mathc + 1
    RTS
.iszero
    LDA #0
    STA mathc
    STA mathc + 1
    RTS
}

IF FALSE
    ; Calculates the cosine of A (0..255), multiplied by Y
.cos
{
    SEC
    SBC #64
}
    ; Calculates the sine of A (0..255), multiplied by Y
.sin
{
    CMP #0
    BPL sinquad12   ; If positive, we don't need to negate Y
    TAX             ; Here, we're relying on SIN(A + 180) = -SIN(A)
    TYA
    EOR #255
    CLC
    ADC #1
    TAY             ; Negate Y
    TXA
    AND #127        ; And convert A to 0..180
.sinquad12
    CMP #64
    BMI sinquad0
    AND #63         ; Here, we're relying on SIN(A) = SIN(180 - A) where A = 90..179
    EOR #63
.sinquad0
    TAX
    LDA sintable, X
    STA matha
    LDA #0
    STA matha + 1
    JMP multbyy
}
ENDIF

.sincos
; Gets the sin (in X) and cosine (in Y) on A (0..255)
    LSR A
    LSR A
    TAX
    CLC
    ADC #16
    AND #63
    TAY
    LDA sincostable, X
    TAX
    LDA sincostable, Y
    TAY
    RTS

ALIGN    64
divmaxx = 50000
divmaxy = 30000
divadd = 33
.divtableLX
    FOR n, 1, 64
    EQUB LO(divmaxx / (n + divadd))
    NEXT
.divtableHX
    FOR n, 1, 64
    EQUB HI(divmaxx / (n + divadd))
    NEXT
.divtableLY
    FOR n, 1, 64
    EQUB LO(divmaxy / (n + divadd))
    NEXT
.divtableHY
    FOR n, 1, 64
    EQUB HI(divmaxy / (n + divadd))
    NEXT
IF FALSE
.sintable
    FOR  n, 0, 63
    EQUB SIN(RAD(n * 90 / 64)) * 255
    NEXT
ENDIF
.sincostable
    FOR n, 0, 63
    EQUB SIN(RAD(n * 360 / 64)) * 16
    NEXT
.theight
    FOR n, 1, 64
    EQUB LO(400 / (n + divadd))
    NEXT

